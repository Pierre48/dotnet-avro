{"version":3,"sources":["webpack:///./utilities/array.js","webpack:///./src/components/references/nuget-package.js","webpack:///./src/pages/guides/kafka.js","webpack:///./src/components/references/dotnet.js"],"names":["module","exports","groupBy","list","key","reduce","map","item","k","has","set","get","push","Map","join","separator","result","index","array","length","NugetPackageReference","children","id","version","others","url","to","title","useStaticQuery","site","siteMetadata","latestRelease","projectName","Helmet","language","DotnetExpansion","typeParameters","methodTypeParameters","substring","DotnetLink","createMemberName","method","getMethodParameters","type","typeBinding","match","methodBinding","createTypeName","bound","getTypeParameters","unbound","Array","getTypeSuffix","test","createDocfxUrl","toLowerCase","DotnetReference"],"mappings":"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","file":"component---src-pages-guides-kafka-js-d92cb56d20f3978d33f9.js","sourcesContent":["/**\n * Groups an array of objects by property.\n *\n * @param {TValue[]} list\n * An array.\n *\n * @param {string} key\n * The name of a property to use as a key.\n *\n * @returns {Map<TKey, TValue[]>}\n * A map of keys to groups.\n *\n * @template TKey, TValue\n */\nfunction groupBy (list, key) {\n  return list.reduce((map, item) => {\n    const k = item[key]\n    if (!map.has(item[key])) {\n      map.set(k, [])\n    }\n\n    map.get(k).push(item)\n    return map\n  }, new Map())\n}\n\n/**\n * Separates items in an array.\n *\n * @param {T[]} list\n * An array.\n *\n * @param {U} separator\n * An item to insert between all elements in the array.\n *\n * @returns {(T|U)[]}\n * An array.\n *\n * @template T, U\n */\nfunction join (list, separator) {\n  return list.reduce((result, item, index, array) => {\n    result.push(item)\n\n    if (index < array.length - 1) {\n      result.push(separator)\n    }\n\n    return result\n  }, [])\n}\n\nmodule.exports = {\n  groupBy, join\n}\n","import React from 'react'\n\nimport ExternalLink from '../site/external-link'\n\nexport default function NugetPackageReference ({ children, id, version, ...others }) {\n  let url = `https://www.nuget.org/packages/${id}`\n\n  if (version) {\n    url += `/${version}`\n  }\n\n  return <ExternalLink {...others} to={url}>{children || id}</ExternalLink>\n}\n","import { graphql, useStaticQuery } from 'gatsby'\nimport React from 'react'\nimport { Helmet } from 'react-helmet'\n\nimport Highlight from '../../components/code/highlight'\nimport DotnetReference from '../../components/references/dotnet'\nimport NugetPackageReference from '../../components/references/nuget-package'\nimport ExternalLink from '../../components/site/external-link'\n\nconst title = 'Building Kafka producers and consumers'\n\nexport default () => {\n  const {\n    site: {\n      siteMetadata: { latestRelease, projectName }\n    }\n  } = useStaticQuery(graphql`\n    query {\n      site {\n        siteMetadata {\n          latestRelease\n          projectName\n        }\n      }\n    }\n  `)\n\n  return (\n    <>\n      <Helmet>\n        <title>{title}</title>\n      </Helmet>\n\n      <h1>{title}</h1>\n      <p>{projectName} ships with first-class support for <ExternalLink to='https://github.com/confluentinc/confluent-kafka-dotnet'>Confluent’s Kafka clients</ExternalLink>, the shortest path to creating Kafka producers and consumers in .NET.</p>\n\n      <h2>Using Confluent’s client builders</h2>\n      <p>First, add a reference to the Chr.Avro.Confluent package:</p>\n      <Highlight language='bash'>{`$ dotnet add package Chr.Avro.Confluent --version ${latestRelease}`}</Highlight>\n      <p>Chr.Avro.Confluent depends on <NugetPackageReference id='Confluent.Kafka' />, which contains <DotnetReference id='T:Confluent.Kafka.ProducerBuilder`2'>producer</DotnetReference> and <DotnetReference id='T:Confluent.Kafka.ConsumerBuilder`2'>consumer</DotnetReference> builders. To build a <ExternalLink to='https://www.confluent.io/confluent-schema-registry/'>Schema Registry</ExternalLink>-integrated producer, use the producer builder in tandem with {projectName}’s Avro extension methods:</p>\n      <Highlight language='csharp'>{`using Chr.Avro.Confluent;\nusing Confluent.Kafka;\nusing Confluent.SchemaRegistry;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace Chr.Avro.Examples.KafkaProducer\n{\n    public class ExampleValue\n    {\n        public string Property { get; set; }\n    }\n\n    public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            var producerConfig = new ProducerConfig()\n            {\n                BootstrapServers = \"broker1:9092,broker2:9092\"\n            };\n\n            var registryConfig = new RegistryConfig()\n            {\n                SchemaRegistryUrl = \"http://registry:8081\"\n            };\n\n            using (var registry = new CachedSchemaRegistryClient(registryConfig))\n            {\n                var builder = new ProducerBuilder<Ignore, ExampleValue>(producerConfig)\n                    .SetAvroValueSerializer(registry, registerAutomatically: AutomaticRegistrationBehavior.Always)\n                    .SetErrorHandler((_, error) => Console.Error.WriteLine(error.ToString()));\n\n                using (var producer = builder.Build())\n                {\n                    await producer.ProduceAsync(\"example_topic\", new Message<Ignore, ExampleValue>\n                    {\n                        Value = new ExampleValue\n                        {\n                            Property = \"example!\"\n                        }\n                    });\n                }\n            }\n        }\n    }\n}`}</Highlight>\n    <p>The serializer assumes (per Confluent convention) that the value subject for <code>example_topic</code> is <code>example_topic-value</code>. (The key subject would be <code>example_topic-key</code>.) When messages are published, the serializer will attempt to pull down a schema from the Schema Registry. The serializer can be configured to generate and register a schema automatically if one doesn’t exist.</p>\n    <p>Building consumers works in a similar way—schemas will be retrieved from the Schema Registry as messages are consumed:</p>\n    <Highlight language='csharp'>{`using Chr.Avro.Confluent;\nusing Confluent.Kafka;\nusing Confluent.SchemaRegistry;\nusing System;\n\nnamespace Chr.Avro.Examples.KafkaConsumer\n{\n    public class ExampleValue\n    {\n        public string Property { get; set; }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var consumerConfig = new ConsumerConfig()\n            {\n                BootstrapServers = \"broker1:9092,broker2:9092\",\n                GroupId = \"example_consumer_group\"\n            };\n\n            var registryConfig = new RegistryConfig()\n            {\n                SchemaRegistryUrl = \"http://registry:8081\"\n            };\n\n            using (var registry = new CachedSchemaRegistryClient(registryClient))\n            {\n                var builder = new ConsumerBuilder<Ignore, ExampleValue>(consumerConfig)\n                    .SetAvroValueDeserializer(registry)\n                    .SetErrorHandler((_, error) => Console.Error.WriteLine(error.ToString()));\n\n                using (var consumer = builder.Build())\n                {\n                    consumer.Subscribe(\"example_topic\");\n\n                    while (true)\n                    {\n                        var result = consumer.Consume();\n                        Console.WriteLine(result.Value.Property);\n                    }\n                }\n            }\n        }\n    }\n}`}</Highlight>\n    </>\n  )\n}\n","import { Link } from 'gatsby'\nimport React from 'react'\n\nimport ExternalLink from '../site/external-link'\n\nimport { join } from '../../../utilities/array'\n\nimport {\n  createDocfxUrl,\n  createMemberName,\n  createTypeName,\n  getMethodParameters,\n  getTypeParameters,\n  getTypeSuffix\n} from '../../../utilities/dotnet'\n\nconst confluentDocfxBase = 'https://docs.confluent.io/current/clients/confluent-kafka-dotnet/api/'\nconst microsoftDocfxBase = 'https://docs.microsoft.com/en-us/dotnet/api/'\n\nfunction DotnetExpansion ({ id, typeParameters = [], methodTypeParameters = [] }) {\n  switch (id.substring(0, 2)) {\n    case 'F:':\n    case 'P:':\n      return <DotnetLink id={id}>{createMemberName(id)}</DotnetLink>\n\n    case 'M:':\n      const method = [<DotnetLink key={id} id={id}>{createMemberName(id)}</DotnetLink>]\n\n      if (methodTypeParameters && methodTypeParameters.length) {\n        method.push('<', ...join(methodTypeParameters , ', '), '>')\n      }\n\n      method.push('(', ...join(getMethodParameters(id).map((type, index) =>\n        <DotnetExpansion key={index} id={`T:${type}`} typeParameters={typeParameters} methodTypeParameters={methodTypeParameters} />\n      ), ', '), ')');\n\n      return method\n\n    case 'T:':\n      const typeBinding = id.match(/^T:`(\\d+)$/)\n      const methodBinding = id.match(/^T:``(\\d+)$/)\n\n      if (typeBinding) {\n        return typeParameters[typeBinding[1]] || ''\n      }\n      else if (methodBinding) {\n        return methodTypeParameters[methodBinding[1]] || ''\n      }\n\n      const type = [<DotnetLink key={id} id={id}>{createTypeName(id)}</DotnetLink>]\n      const bound = getTypeParameters(id)\n      const unbound = id.match(/^T:(.+)`(\\d+)$/)\n\n      if (bound || unbound) {\n        type.push('<')\n\n        if (bound) {\n          type.push(...join(bound.map((type, index) =>\n            <DotnetExpansion key={index} id={`T:${type}`} typeParameters={typeParameters} methodTypeParameters={methodTypeParameters} />\n          ), ', '))\n        }\n\n        if (unbound) {\n          id = unbound[1]\n          type.push(new Array(+unbound[2]).join(','))\n        }\n\n        type.push('>')\n      }\n\n      type.push(getTypeSuffix(id))\n      return type\n\n    default:\n      return <DotnetLink id={id}>{id.substring(2)}</DotnetLink>\n  }\n}\n\nfunction DotnetLink ({ children, id }) {\n  if (/^[EFMNPT]:Chr\\.Avro/.test(id)) {\n    return <Link to={`/api/${createDocfxUrl(id).toLowerCase()}`}>{children}</Link>\n  }\n\n  if (/^[EFMNPT]:Confluent\\.(?:Kafka|SchemaRegistry)/.test(id)) {\n    return <ExternalLink to={`${confluentDocfxBase}${createDocfxUrl(id)}.html`}>{children}</ExternalLink>\n  }\n\n  if (/^[EFMNPT]:(?:Microsoft|System)/.test(id)) {\n    return <ExternalLink to={`${microsoftDocfxBase}${createDocfxUrl(id).toLowerCase()}`}>{children}</ExternalLink>\n  }\n\n  return children\n}\n\nexport default function DotnetReference ({ children, id, typeParameters, methodTypeParameters, ...others }) {\n  return children\n    ? <DotnetLink id={id} {...others}>{children}</DotnetLink>\n    : <code {...others}>\n        <DotnetExpansion id={id} typeParameters={typeParameters} methodTypeParameters={methodTypeParameters} />\n      </code>\n}\n"],"sourceRoot":""}