{"version":3,"sources":["webpack:///./utilities/array.js","webpack:///./src/components/references/dotnet.js","webpack:///./src/pages/guides/cli-create.js"],"names":["module","exports","groupBy","list","key","reduce","map","item","k","has","set","get","push","Map","join","separator","result","index","array","length","DotnetExpansion","id","typeParameters","methodTypeParameters","substring","DotnetLink","createMemberName","method","getMethodParameters","type","typeBinding","match","methodBinding","createTypeName","bound","getTypeParameters","unbound","Array","getTypeSuffix","children","test","to","createDocfxUrl","toLowerCase","DotnetReference","others","title","useStaticQuery","site","siteMetadata","latestRelease","projectName","language","inline"],"mappings":"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","file":"component---src-pages-guides-cli-create-js-42c6c7c59254e5d9e380.js","sourcesContent":["/**\n * Groups an array of objects by property.\n *\n * @param {TValue[]} list\n * An array.\n *\n * @param {string} key\n * The name of a property to use as a key.\n *\n * @returns {Map<TKey, TValue[]>}\n * A map of keys to groups.\n *\n * @template TKey, TValue\n */\nfunction groupBy (list, key) {\n  return list.reduce((map, item) => {\n    const k = item[key]\n    if (!map.has(item[key])) {\n      map.set(k, [])\n    }\n\n    map.get(k).push(item)\n    return map\n  }, new Map())\n}\n\n/**\n * Separates items in an array.\n *\n * @param {T[]} list\n * An array.\n *\n * @param {U} separator\n * An item to insert between all elements in the array.\n *\n * @returns {(T|U)[]}\n * An array.\n *\n * @template T, U\n */\nfunction join (list, separator) {\n  return list.reduce((result, item, index, array) => {\n    result.push(item)\n\n    if (index < array.length - 1) {\n      result.push(separator)\n    }\n\n    return result\n  }, [])\n}\n\nmodule.exports = {\n  groupBy, join\n}\n","import { Link } from 'gatsby'\nimport React from 'react'\n\nimport ExternalLink from '../site/external-link'\n\nimport { join } from '../../../utilities/array'\n\nimport {\n  createDocfxUrl,\n  createMemberName,\n  createTypeName,\n  getMethodParameters,\n  getTypeParameters,\n  getTypeSuffix\n} from '../../../utilities/dotnet'\n\nconst confluentDocfxBase = 'https://docs.confluent.io/current/clients/confluent-kafka-dotnet/api/'\nconst microsoftDocfxBase = 'https://docs.microsoft.com/en-us/dotnet/api/'\n\nfunction DotnetExpansion ({ id, typeParameters = [], methodTypeParameters = [] }) {\n  switch (id.substring(0, 2)) {\n    case 'F:':\n    case 'P:':\n      return <DotnetLink id={id}>{createMemberName(id)}</DotnetLink>\n\n    case 'M:':\n      const method = [<DotnetLink key={id} id={id}>{createMemberName(id)}</DotnetLink>]\n\n      if (methodTypeParameters && methodTypeParameters.length) {\n        method.push('<', ...join(methodTypeParameters , ', '), '>')\n      }\n\n      method.push('(', ...join(getMethodParameters(id).map((type, index) =>\n        <DotnetExpansion key={index} id={`T:${type}`} typeParameters={typeParameters} methodTypeParameters={methodTypeParameters} />\n      ), ', '), ')');\n\n      return method\n\n    case 'T:':\n      const typeBinding = id.match(/^T:`(\\d+)$/)\n      const methodBinding = id.match(/^T:``(\\d+)$/)\n\n      if (typeBinding) {\n        return typeParameters[typeBinding[1]] || ''\n      }\n      else if (methodBinding) {\n        return methodTypeParameters[methodBinding[1]] || ''\n      }\n\n      const type = [<DotnetLink key={id} id={id}>{createTypeName(id)}</DotnetLink>]\n      const bound = getTypeParameters(id)\n      const unbound = id.match(/^T:(.+)`(\\d+)$/)\n\n      if (bound || unbound) {\n        type.push('<')\n\n        if (bound) {\n          type.push(...join(bound.map((type, index) =>\n            <DotnetExpansion key={index} id={`T:${type}`} typeParameters={typeParameters} methodTypeParameters={methodTypeParameters} />\n          ), ', '))\n        }\n\n        if (unbound) {\n          id = unbound[1]\n          type.push(new Array(+unbound[2]).join(','))\n        }\n\n        type.push('>')\n      }\n\n      type.push(getTypeSuffix(id))\n      return type\n\n    default:\n      return <DotnetLink id={id}>{id.substring(2)}</DotnetLink>\n  }\n}\n\nfunction DotnetLink ({ children, id }) {\n  if (/^[EFMNPT]:Chr\\.Avro/.test(id)) {\n    return <Link to={`/api/${createDocfxUrl(id).toLowerCase()}`}>{children}</Link>\n  }\n\n  if (/^[EFMNPT]:Confluent\\.(?:Kafka|SchemaRegistry)/.test(id)) {\n    return <ExternalLink to={`${confluentDocfxBase}${createDocfxUrl(id)}.html`}>{children}</ExternalLink>\n  }\n\n  if (/^[EFMNPT]:(?:Microsoft|System)/.test(id)) {\n    return <ExternalLink to={`${microsoftDocfxBase}${createDocfxUrl(id).toLowerCase()}`}>{children}</ExternalLink>\n  }\n\n  return children\n}\n\nexport default function DotnetReference ({ children, id, typeParameters, methodTypeParameters, ...others }) {\n  return children\n    ? <DotnetLink id={id} {...others}>{children}</DotnetLink>\n    : <code {...others}>\n        <DotnetExpansion id={id} typeParameters={typeParameters} methodTypeParameters={methodTypeParameters} />\n      </code>\n}\n","import { Link, graphql, useStaticQuery } from 'gatsby'\nimport React from 'react'\nimport { Helmet } from 'react-helmet'\n\nimport Highlight from '../../components/code/highlight'\nimport DotnetReference from '../../components/references/dotnet'\nimport ExternalLink from '../../components/site/external-link'\n\nconst title = 'Creating schemas from .NET types'\n\nexport default () => {\n  const {\n    site: {\n      siteMetadata: { latestRelease, projectName }\n    }\n  } = useStaticQuery(graphql`\n    query {\n      site {\n        siteMetadata {\n          latestRelease\n          projectName\n        }\n      }\n    }\n  `)\n\n  return (\n    <>\n      <Helmet>\n        <title>{title}</title>\n      </Helmet>\n\n      <h1>{title}</h1>\n      <p>Creating schemas from complex .NET types is a time-saving way to get started with Avro. {projectName} recognizes most commonly used types and supports classes, structs, and enums, so it’s usually possible to get a working schema with no additional manipulation.</p>\n      <p>For detailed information about how types are matched to schemas, see the <Link to='/internals/mapping'>types and conversions</Link> documentation.</p>\n\n      <h2>Getting started</h2>\n      <p>If you haven’t already, install the {projectName} CLI:</p>\n      <Highlight language='bash'>{`$ dotnet tool install Chr.Avro.Cli --global\n  Tool 'chr.avro.cli' (version '${latestRelease}') was successfully installed.`}</Highlight>\n      <p>After the CLI tool has been installed, you can invoke it using <code>dotnet avro</code>. If the install command fails, make sure you have the latest version of the <ExternalLink to='https://dotnet.microsoft.com/download'>.NET Core SDK</ExternalLink> installed.</p>\n\n      <h2>Using the CLI</h2>\n      <p>To create a schema for a type, use the <Link to='/cli#create'><Highlight inline language='bash'>create</Highlight></Link> command. You’ll need to provide the type’s full name as well as the path to a compiled assembly that contains it:</p>\n      <Highlight language='bash'>{`$ dotnet avro create --type ExampleNamespace.ExampleLibrary.ExampleClass --assembly bin/Debug/netstandard2.0/ExampleNamespace.ExampleLibrary.dll\n{\"name\":\"ExampleNamespace.ExampleLibrary.ExampleClass\",\"type\":\"record\",\"fields\":[{\"name\":\"ExampleProperty\",\"type\":\"int\"}]}`}</Highlight>\n\n      <h2>Customizing generated schemas</h2>\n      <p>The CLI ships with some convenience options:</p>\n      <ul>\n        <li>\n          <p>The <strong><code>--nullable-references</code></strong> option causes all reference types to be written as nullable unions. This is useful when you prefer to keep .NET’s nullable semantics.</p>\n        </li>\n        <li>\n          <p>The <strong><code>--enums-as-integers</code></strong> option causes enums to be represented as <Highlight inline language='avro'>\"int\"</Highlight> or <Highlight inline language='avro'>\"long\"</Highlight> schemas instead of <Highlight inline language='avro'>\"enum\"</Highlight> schemas.</p>\n        </li>\n      </ul>\n      <p>{projectName} also recognizes <DotnetReference id='T:System.Runtime.Serialization.DataContractAttribute'>data contract attributes</DotnetReference>, which can be used to customize names.</p>\n      <p>If you need to make more complicated modifications to a generated schema, you can customize the schema creation process in code:</p>\n      <Highlight language='csharp'>{`using Chr.Avro.Abstract;\nusing Chr.Avro.Representation;\nusing System;\n\nnamespace Chr.Avro.Examples.SchemaCustomization\n{\n    public class ExampleClass\n    {\n        public int NumericProperty { get; set; }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var builder = new SchemaBuilder();\n            var schema = builder.BuildSchema<ExampleClass>(); // a RecordSchema instance\n\n            // do modifications here\n\n            var writer = new JsonSchemaWriter();\n            Console.WriteLine(writer.Write(schema));\n        }\n    }\n}`}</Highlight>\n    </>\n  )\n}\n"],"sourceRoot":""}