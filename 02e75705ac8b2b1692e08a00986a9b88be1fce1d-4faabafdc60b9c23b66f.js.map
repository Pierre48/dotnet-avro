{"version":3,"sources":["webpack:///./utilities/array.js","webpack:///./node_modules/@rgrove/parse-xml/dist/commonjs/lib/syntax.js","webpack:///./src/components/code/render.js","webpack:///./src/components/dotnet/xml-doc.js","webpack:///./src/templates/dotnet.module.scss","webpack:///./src/components/references/dotnet.js","webpack:///./src/components/site/breadcrumb.module.scss","webpack:///./node_modules/@rgrove/parse-xml/dist/commonjs/index.js","webpack:///./src/components/site/breadcrumb.js","webpack:///./utilities/xml.js"],"names":["module","exports","groupBy","list","key","reduce","map","item","k","has","set","get","push","Map","join","separator","result","index","array","length","_templateObject18","data","_taggedTemplateLiteralLoose","_templateObject17","_templateObject16","_templateObject15","_templateObject14","_templateObject13","_templateObject12","_templateObject11","_templateObject10","_templateObject9","_templateObject8","_templateObject7","_templateObject6","_templateObject5","_templateObject4","_templateObject3","_templateObject2","_templateObject","strings","raw","slice","regex","lastIndex","pattern","_len","arguments","embeddedPatterns","Array","_key","i","replace","source","RegExp","Char","CharData","NameStartChar","NameChar","Name","Reference","S","Eq","Attribute","CDSect","EmptyElemTag","ETag","STag","CharOnly","Comment","doctypedecl","PI","XMLDecl","Anchored","Global","Object","keys","forEach","name","xml","hydrate","nodes","node","type","content","children","match","attributes","createElement","Fragment","text","filter","c","parse","cref","id","DotnetExpansion","typeParameters","methodTypeParameters","substring","DotnetLink","createMemberName","method","getMethodParameters","typeBinding","methodBinding","createTypeName","bound","getTypeParameters","unbound","getTypeSuffix","test","to","createDocfxUrl","toLowerCase","DotnetReference","others","Syntax","emptyArray","freeze","emptyObject","create","namedEntities","addNode","state","parent","toJSON","nodeToJson","addText","prevNode","consumeCDSect","_scan","scan","options","preserveCdata","consumeCharData","cdataCloseIndex","indexOf","pos","prevPos","error","search","consumeComment","preserveComments","trim","consumeMisc","consumePI","consumeWhitespace","_scan7","target","consumeReference","ref","replaceReference","message","column","excerpt","line","_char","eol","excerptStart","err","Error","repeat","json","assign","this","normalizeAttrValue","value","codePoint","parseInt","isNaN","_char2","String","fromCodePoint","resolveUndefinedEntity","resolvedValue","ignoreUndefinedEntities","matches","doc","bind","consumeDoctypeDecl","consumeProlog","consumeElement","_scan4","tag","attrs","isEmpty","_scan5","parsedAttrs","attrPairs","sort","len","attrPair","eqMatch","parseAttrs","xmlSpace","preserveWhitespace","isEof","isArray","className","styles","breadcrumb","child","require","getMarkup","include","getText"],"mappings":"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","file":"02e75705ac8b2b1692e08a00986a9b88be1fce1d-4faabafdc60b9c23b66f.js","sourcesContent":["/**\n * Groups an array of objects by property.\n *\n * @param {TValue[]} list\n * An array.\n *\n * @param {string} key\n * The name of a property to use as a key.\n *\n * @returns {Map<TKey, TValue[]>}\n * A map of keys to groups.\n *\n * @template TKey, TValue\n */\nfunction groupBy (list, key) {\n  return list.reduce((map, item) => {\n    const k = item[key]\n    if (!map.has(item[key])) {\n      map.set(k, [])\n    }\n\n    map.get(k).push(item)\n    return map\n  }, new Map())\n}\n\n/**\n * Separates items in an array.\n *\n * @param {T[]} list\n * An array.\n *\n * @param {U} separator\n * An item to insert between all elements in the array.\n *\n * @returns {(T|U)[]}\n * An array.\n *\n * @template T, U\n */\nfunction join (list, separator) {\n  return list.reduce((result, item, index, array) => {\n    result.push(item)\n\n    if (index < array.length - 1) {\n      result.push(separator)\n    }\n\n    return result\n  }, [])\n}\n\nmodule.exports = {\n  groupBy, join\n}\n","'use strict'; // To improve readability, the regular expression patterns in this file are\n// written as tagged template literals. The `regex` tag function strips literal\n// whitespace characters and line comments beginning with `//` and returns a\n// RegExp instance.\n//\n// Escape sequences are preserved as-is in the resulting regex, so\n// double-escaping isn't necessary. A pattern may embed another pattern using\n// `${}` interpolation.\n// -- Common Symbols -----------------------------------------------------------\n\nfunction _templateObject18() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  <?xml\\n    \", \"\\n    [sS]+?\\n  ?>\\n\"], [\"\\n  <\\\\?xml\\n    \", \"\\n    [\\\\s\\\\S]+?\\n  \\\\?>\\n\"]);\n\n  _templateObject18 = function _templateObject18() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject17() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  <?\\n    // Group 1: PITarget\\n    (\\n      \", \"\\n    )\\n\\n    (?:\\n      \", \"\\n      (?:\", \")*?\\n    )?\\n  ?>\\n\"], [\"\\n  <\\\\?\\n    // Group 1: PITarget\\n    (\\n      \", \"\\n    )\\n\\n    (?:\\n      \", \"\\n      (?:\", \")*?\\n    )?\\n  \\\\?>\\n\"]);\n\n  _templateObject17 = function _templateObject17() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject16() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  <!DOCTYPE\\n    \", \"\\n\\n    [^[>]*\\n\\n    (?:\\n      [ [sS]+? ]\\n      (?:\", \")?\\n    )?\\n  >\\n\"], [\"\\n  <!DOCTYPE\\n    \", \"\\n\\n    [^[>]*\\n\\n    (?:\\n      \\\\[ [\\\\s\\\\S]+? \\\\]\\n      (?:\", \")?\\n    )?\\n  >\\n\"]);\n\n  _templateObject16 = function _templateObject16() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject15() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  <!--\\n    // Group 1: Comment text (optional)\\n    (\\n      (?:\\n        (?!-) \", \"\\n        | - (?!-) \", \"\\n      )*\\n    )\\n  -->\\n\"]);\n\n  _templateObject15 = function _templateObject15() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject14() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  ^(?:\", \")*$\\n\"]);\n\n  _templateObject14 = function _templateObject14() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject13() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  <\\n    // Group 1: Start tag name\\n    (\", \")\\n\\n    // Group 2: Attributes (optional)\\n    (\\n      (?:\\n        \", \"\\n        \", \"\\n      )*\\n    )\\n\\n    (?:\", \")?\\n  >\\n\"]);\n\n  _templateObject13 = function _templateObject13() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject12() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  </\\n    // Group 1: End tag name\\n    (\", \")\\n    (?:\", \")?\\n  >\\n\"]);\n\n  _templateObject12 = function _templateObject12() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject11() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  <\\n    // Group 1: Element name\\n    (\", \")\\n\\n    // Group 2: Attributes (optional)\\n    (\\n      (?:\\n        \", \"\\n        \", \"\\n      )*\\n    )\\n\\n    (?:\", \")?\\n  />\\n\"]);\n\n  _templateObject11 = function _templateObject11() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject10() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  <![CDATA[\\n    // Group 1: CData text content (optional)\\n    (\\n      (?:\", \")*?\\n    )\\n  ]]>\\n\"], [\"\\n  <!\\\\[CDATA\\\\[\\n    // Group 1: CData text content (optional)\\n    (\\n      (?:\", \")*?\\n    )\\n  \\\\]\\\\]>\\n\"]);\n\n  _templateObject10 = function _templateObject10() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject9() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  \", \"\\n  \", \"\\n\\n  (?:\\n    \\\"(?:\\n      [^<\\\"]\\n    )*\\\"\\n\\n    |\\n\\n    '(?:\\n      [^<']\\n    )*'\\n  )\\n\"]);\n\n  _templateObject9 = function _templateObject9() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject8() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  (?:\", \")?\\n  =\\n  (?:\", \")?\\n\"]);\n\n  _templateObject8 = function _templateObject8() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject7() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  [ \\t\\r\\n]+\\n\"], [\"\\n  [\\\\x20\\\\t\\\\r\\\\n]+\\n\"]);\n\n  _templateObject7 = function _templateObject7() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject6() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  &[^s&;]*;?\\n\"], [\"\\n  &[^\\\\s&;]*;?\\n\"]);\n\n  _templateObject6 = function _templateObject6() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject5() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  \", \"\\n  (?:\", \")*\\n\"]);\n\n  _templateObject5 = function _templateObject5() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject4() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  (?:\\n    \", \"\\n\\n    |\\n\\n    [\\n      .\\n      0-9\\n      \\xB7\\n      \\u0300-\\u036F\\n      \\u203F-\\u2040\\n      -\\n    ]\\n  )\\n\"], [\"\\n  (?:\\n    \", \"\\n\\n    |\\n\\n    [\\n      .\\n      0-9\\n      \\\\xB7\\n      \\\\u0300-\\\\u036F\\n      \\\\u203F-\\\\u2040\\n      -\\n    ]\\n  )\\n\"]);\n\n  _templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject3() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  (?:\\n    [\\n      :\\n      A-Z\\n      _\\n      a-z\\n      \\xC0-\\xD6\\n      \\xD8-\\xF6\\n      \\xF8-\\u02FF\\n      \\u0370-\\u037D\\n      \\u037F-\\u1FFF\\n      \\u200C-\\u200D\\n      \\u2070-\\u218F\\n      \\u2C00-\\u2FEF\\n      \\u3001-\\uD7FF\\n      \\uF900-\\uFDCF\\n      \\uFDF0-\\uFFFD\\n    ]\\n\\n    |\\n\\n    [\\uD800-\\uDB7F][\\uDC00-\\uDFFF]\\n  )\\n\"], [\"\\n  (?:\\n    [\\n      :\\n      A-Z\\n      _\\n      a-z\\n      \\\\xC0-\\\\xD6\\n      \\\\xD8-\\\\xF6\\n      \\\\xF8-\\\\u02FF\\n      \\\\u0370-\\\\u037D\\n      \\\\u037F-\\\\u1FFF\\n      \\\\u200C-\\\\u200D\\n      \\\\u2070-\\\\u218F\\n      \\\\u2C00-\\\\u2FEF\\n      \\\\u3001-\\\\uD7FF\\n      \\\\uF900-\\\\uFDCF\\n      \\\\uFDF0-\\\\uFFFD\\n    ]\\n\\n    |\\n\\n    [\\\\uD800-\\\\uDB7F][\\\\uDC00-\\\\uDFFF]\\n  )\\n\"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  [^<&]+\\n\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  (?:\\n    [\\n      \\t\\n      \\n\\n      \\r\\n       -\\uD7FF\\n      \\uE000-\\uFFFD\\n    ]\\n\\n    |\\n\\n    [\\uD800-\\uDBFF][\\uDC00-\\uDFFF]\\n  )\\n\"], [\"\\n  (?:\\n    [\\n      \\\\t\\n      \\\\n\\n      \\\\r\\n      \\\\x20-\\\\uD7FF\\n      \\\\uE000-\\\\uFFFD\\n    ]\\n\\n    |\\n\\n    [\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]\\n  )\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteralLoose(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  strings.raw = raw;\n  return strings;\n}\n\nexports.Char = regex(_templateObject()); // Partial implementation.\n//\n// To be compliant, the matched text must result in an error if it contains the\n// string `]]>`, but that can't be easily represented here so we do it in the\n// parser.\n\nexports.CharData = regex(_templateObject2());\nexports.NameStartChar = regex(_templateObject3());\nexports.NameChar = regex(_templateObject4(), exports.NameStartChar);\nexports.Name = regex(_templateObject5(), exports.NameStartChar, exports.NameChar); // Loose implementation. The entity will be validated in the `replaceReference`\n// function.\n\nexports.Reference = regex(_templateObject6());\nexports.S = regex(_templateObject7()); // -- Attributes ---------------------------------------------------------------\n\nexports.Eq = regex(_templateObject8(), exports.S, exports.S);\nexports.Attribute = regex(_templateObject9(), exports.Name, exports.Eq); // -- Elements -----------------------------------------------------------------\n\nexports.CDSect = regex(_templateObject10(), exports.Char);\nexports.EmptyElemTag = regex(_templateObject11(), exports.Name, exports.S, exports.Attribute, exports.S);\nexports.ETag = regex(_templateObject12(), exports.Name, exports.S);\nexports.STag = regex(_templateObject13(), exports.Name, exports.S, exports.Attribute, exports.S); // -- Misc ---------------------------------------------------------------------\n// Special pattern that matches an entire string consisting only of `Char`\n// characters.\n\nexports.CharOnly = regex(_templateObject14(), exports.Char);\nexports.Comment = regex(_templateObject15(), exports.Char, exports.Char); // Loose implementation since doctype declarations are discarded.\n//\n// It's not possible to fully parse a doctype declaration with a regex, but\n// since we just discard them we can skip parsing the fiddly inner bits and use\n// a regex to speed things up.\n\nexports.doctypedecl = regex(_templateObject16(), exports.S, exports.S); // Loose implementation since processing instructions are discarded.\n\nexports.PI = regex(_templateObject17(), exports.Name, exports.S, exports.Char); // Loose implementation since XML declarations are discarded.\n\nexports.XMLDecl = regex(_templateObject18(), exports.S); // -- Helpers ------------------------------------------------------------------\n\nexports.Anchored = {};\nexports.Global = {}; // Create anchored and global variations of each pattern.\n\nObject.keys(exports).forEach(function (name) {\n  if (name !== 'Anchored' && name !== 'CharOnly' && name !== 'Global') {\n    var pattern = exports[name];\n    exports.Anchored[name] = new RegExp('^' + pattern.source);\n    exports.Global[name] = new RegExp(pattern.source, 'g');\n  }\n});\n\nfunction regex(strings) {\n  var length = strings.length,\n      raw = strings.raw;\n  var lastIndex = length - 1;\n  var pattern = '';\n\n  for (var _len = arguments.length, embeddedPatterns = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    embeddedPatterns[_key - 1] = arguments[_key];\n  }\n\n  for (var i = 0; i < length; ++i) {\n    pattern += raw[i].replace(/(^|[^\\\\])\\/\\/.*$/gm, '$1') // remove end-of-line comments\n    .replace(/\\s+/g, ''); // remove all whitespace\n\n    if (i < lastIndex) {\n      pattern += embeddedPatterns[i].source;\n    }\n  }\n\n  return new RegExp(pattern);\n}","import { Fragment, createElement } from 'react'\n\nimport { parse } from '../../../utilities/xml'\n\nexport default ({ map = {}, xml }) => {\n  const hydrate = (nodes = []) => nodes\n    .map((node, index) => {\n      switch (node.type) {\n        case 'element':\n          const content = hydrate(node.children)\n          const match = map[node.name]\n          const attributes = match ? node.attributes : {}\n\n          return createElement(match || Fragment, { ...attributes, key: index }, content)\n\n        case 'text':\n          return node.text\n\n        default:\n          return false\n      }\n    })\n    .filter(c => !!c)\n\n  return hydrate(parse(`<root>${xml}</root>`).children)\n}\n","import React from 'react'\n\nimport Render from '../code/render'\nimport DotnetReference from '../references/dotnet'\n\nexport default ({ xml }) =>\n  <Render xml={xml} map={{\n    'see': ({ cref }) => <DotnetReference id={cref} />\n  }} />\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"title\":\"dotnet-module--title--6RDD-\"};","import { Link } from 'gatsby'\nimport React from 'react'\n\nimport ExternalLink from '../site/external-link'\n\nimport { join } from '../../../utilities/array'\n\nimport {\n  createDocfxUrl,\n  createMemberName,\n  createTypeName,\n  getMethodParameters,\n  getTypeParameters,\n  getTypeSuffix\n} from '../../../utilities/dotnet'\n\nconst confluentDocfxBase = 'https://docs.confluent.io/current/clients/confluent-kafka-dotnet/api/'\nconst microsoftDocfxBase = 'https://docs.microsoft.com/en-us/dotnet/api/'\n\nfunction DotnetExpansion ({ id, typeParameters = [], methodTypeParameters = [] }) {\n  switch (id.substring(0, 2)) {\n    case 'F:':\n    case 'P:':\n      return <DotnetLink id={id}>{createMemberName(id)}</DotnetLink>\n\n    case 'M:':\n      const method = [<DotnetLink key={id} id={id}>{createMemberName(id)}</DotnetLink>]\n\n      if (methodTypeParameters && methodTypeParameters.length) {\n        method.push('<', ...join(methodTypeParameters , ', '), '>')\n      }\n\n      method.push('(', ...join(getMethodParameters(id).map((type, index) =>\n        <DotnetExpansion key={index} id={`T:${type}`} typeParameters={typeParameters} methodTypeParameters={methodTypeParameters} />\n      ), ', '), ')');\n\n      return method\n\n    case 'T:':\n      const typeBinding = id.match(/^T:`(\\d+)$/)\n      const methodBinding = id.match(/^T:``(\\d+)$/)\n\n      if (typeBinding) {\n        return typeParameters[typeBinding[1]] || ''\n      }\n      else if (methodBinding) {\n        return methodTypeParameters[methodBinding[1]] || ''\n      }\n\n      const type = [<DotnetLink key={id} id={id}>{createTypeName(id)}</DotnetLink>]\n      const bound = getTypeParameters(id)\n      const unbound = id.match(/^T:(.+)`(\\d+)$/)\n\n      if (bound || unbound) {\n        type.push('<')\n\n        if (bound) {\n          type.push(...join(bound.map((type, index) =>\n            <DotnetExpansion key={index} id={`T:${type}`} typeParameters={typeParameters} methodTypeParameters={methodTypeParameters} />\n          ), ', '))\n        }\n\n        if (unbound) {\n          id = unbound[1]\n          type.push(new Array(+unbound[2]).join(','))\n        }\n\n        type.push('>')\n      }\n\n      type.push(getTypeSuffix(id))\n      return type\n\n    default:\n      return <DotnetLink id={id}>{id.substring(2)}</DotnetLink>\n  }\n}\n\nfunction DotnetLink ({ children, id }) {\n  if (/^[EFMNPT]:Chr\\.Avro/.test(id)) {\n    return <Link to={`/api/${createDocfxUrl(id).toLowerCase()}`}>{children}</Link>\n  }\n\n  if (/^[EFMNPT]:Confluent\\.(?:Kafka|SchemaRegistry)/.test(id)) {\n    return <ExternalLink to={`${confluentDocfxBase}${createDocfxUrl(id)}.html`}>{children}</ExternalLink>\n  }\n\n  if (/^[EFMNPT]:(?:Microsoft|System)/.test(id)) {\n    return <ExternalLink to={`${microsoftDocfxBase}${createDocfxUrl(id).toLowerCase()}`}>{children}</ExternalLink>\n  }\n\n  return children\n}\n\nexport default function DotnetReference ({ children, id, typeParameters, methodTypeParameters, ...others }) {\n  return children\n    ? <DotnetLink id={id} {...others}>{children}</DotnetLink>\n    : <code {...others}>\n        <DotnetExpansion id={id} typeParameters={typeParameters} methodTypeParameters={methodTypeParameters} />\n      </code>\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"breadcrumb\":\"breadcrumb-module--breadcrumb--Pnrca\"};","'use strict';\n\nvar emptyArray = Object.freeze([]);\nvar emptyObject = Object.freeze(Object.create(null));\nvar namedEntities = Object.freeze({\n  '&amp;': '&',\n  '&apos;': \"'\",\n  '&gt;': '>',\n  '&lt;': '<',\n  '&quot;': '\"'\n});\nvar NODE_TYPE_CDATA = 'cdata';\nvar NODE_TYPE_COMMENT = 'comment';\nvar NODE_TYPE_DOCUMENT = 'document';\nvar NODE_TYPE_ELEMENT = 'element';\nvar NODE_TYPE_TEXT = 'text';\nvar Syntax;\n\nmodule.exports = function parseXml(xml, options) {\n  if (options === void 0) {\n    options = emptyObject;\n  }\n\n  if (Syntax === void 0) {\n    // Lazy require to defer regex parsing until first use.\n    Syntax = require('./lib/syntax');\n  }\n\n  if (xml[0] === \"\\uFEFF\") {\n    // Strip byte order mark.\n    xml = xml.slice(1);\n  }\n\n  xml = xml.replace(/\\r\\n?/g, '\\n'); // Normalize CRLF and CR to LF.\n\n  var doc = {\n    type: NODE_TYPE_DOCUMENT,\n    children: [],\n    parent: null,\n    toJSON: nodeToJson\n  };\n  var state = {\n    length: xml.length,\n    options: options,\n    parent: doc,\n    pos: 0,\n    prevPos: 0,\n    xml: xml\n  };\n  state.replaceReference = replaceReference.bind(state);\n  consumeProlog(state);\n\n  if (!consumeElement(state)) {\n    error(state, 'Root element is missing or invalid');\n  }\n\n  while (consumeMisc(state)) {} // eslint-disable-line no-empty\n\n\n  if (!isEof(state)) {\n    error(state, \"Extra content at the end of the document\");\n  }\n\n  return doc;\n}; // -- Private Functions --------------------------------------------------------\n\n\nfunction addNode(state, node) {\n  node.parent = state.parent;\n  node.toJSON = nodeToJson;\n  state.parent.children.push(node);\n}\n\nfunction addText(state, text) {\n  var children = state.parent.children;\n  var prevNode = children[children.length - 1];\n\n  if (prevNode !== void 0 && prevNode.type === NODE_TYPE_TEXT) {\n    // The previous node is a text node, so we can append to it and avoid\n    // creating another node.\n    prevNode.text += text;\n  } else {\n    addNode(state, {\n      type: NODE_TYPE_TEXT,\n      text: text\n    });\n  }\n} // Each `consume*` function takes the current state as an argument and returns\n// `true` if `state.pos` was advanced (meaning some XML was consumed) or `false`\n// if nothing was consumed.\n\n\nfunction consumeCDSect(state) {\n  var _scan = scan(state, Syntax.Anchored.CDSect),\n      match = _scan[0],\n      text = _scan[1];\n\n  if (match === void 0) {\n    return false;\n  }\n\n  if (state.options.preserveCdata) {\n    addNode(state, {\n      type: NODE_TYPE_CDATA,\n      text: text\n    });\n  } else {\n    addText(state, text);\n  }\n\n  return true;\n}\n\nfunction consumeCharData(state) {\n  var _scan2 = scan(state, Syntax.Anchored.CharData),\n      text = _scan2[0];\n\n  if (text === void 0) {\n    return false;\n  }\n\n  var cdataCloseIndex = text.indexOf(']]>');\n\n  if (cdataCloseIndex !== -1) {\n    state.pos = state.prevPos + cdataCloseIndex;\n    error(state, 'Element content may not contain the CDATA section close delimiter `]]>`');\n  } // Note: XML 1.0 5th ed. says `CharData` is \"any string of characters which\n  // does not contain the start-delimiter of any markup and does not include the\n  // CDATA-section-close delimiter\", but the conformance test suite and\n  // well-established parsers like libxml seem to restrict `CharData` to\n  // characters that match the `Char` symbol, so that's what I've done here.\n\n\n  if (!Syntax.CharOnly.test(text)) {\n    state.pos = state.prevPos + text.search(new RegExp(\"(?!\" + Syntax.Char.source + \")\"));\n    error(state, 'Element content contains an invalid character');\n  }\n\n  addText(state, text);\n  return true;\n}\n\nfunction consumeComment(state) {\n  var _scan3 = scan(state, Syntax.Anchored.Comment),\n      content = _scan3[1];\n\n  if (content === void 0) {\n    return false;\n  }\n\n  if (state.options.preserveComments) {\n    addNode(state, {\n      type: NODE_TYPE_COMMENT,\n      content: content.trim()\n    });\n  }\n\n  return true;\n}\n\nfunction consumeDoctypeDecl(state) {\n  return scan(state, Syntax.Anchored.doctypedecl).length > 0;\n}\n\nfunction consumeElement(state) {\n  var _scan4 = scan(state, Syntax.Anchored.EmptyElemTag),\n      tag = _scan4[0],\n      name = _scan4[1],\n      attrs = _scan4[2];\n\n  var isEmpty = tag !== void 0;\n\n  if (!isEmpty) {\n    var _scan5 = scan(state, Syntax.Anchored.STag);\n\n    tag = _scan5[0];\n    name = _scan5[1];\n    attrs = _scan5[2];\n\n    if (tag === void 0) {\n      return false;\n    }\n  }\n\n  var parent = state.parent;\n  var parsedAttrs = parseAttrs(state, attrs);\n  var node = {\n    type: NODE_TYPE_ELEMENT,\n    name: name,\n    attributes: parsedAttrs,\n    children: []\n  };\n  var xmlSpace = parsedAttrs['xml:space'];\n\n  if (xmlSpace === 'preserve' || xmlSpace !== 'default' && parent.preserveWhitespace) {\n    node.preserveWhitespace = true;\n  }\n\n  if (!isEmpty) {\n    state.parent = node;\n    consumeCharData(state);\n\n    while (consumeElement(state) || consumeReference(state) || consumeCDSect(state) || consumePI(state) || consumeComment(state)) {\n      consumeCharData(state);\n    }\n\n    var _scan6 = scan(state, Syntax.Anchored.ETag),\n        endName = _scan6[1];\n\n    if (endName !== name) {\n      state.pos = state.prevPos;\n      error(state, \"Missing end tag for element \" + name);\n    }\n\n    state.parent = parent;\n  }\n\n  addNode(state, node);\n  return true;\n}\n\nfunction consumeMisc(state) {\n  return consumeComment(state) || consumePI(state) || consumeWhitespace(state);\n}\n\nfunction consumePI(state) {\n  var _scan7 = scan(state, Syntax.Anchored.PI),\n      match = _scan7[0],\n      target = _scan7[1];\n\n  if (match === void 0) {\n    return false;\n  }\n\n  if (target.toLowerCase() === 'xml') {\n    state.pos = state.prevPos;\n    error(state, 'XML declaration is only allowed at the start of the document');\n  }\n\n  return true;\n}\n\nfunction consumeProlog(state) {\n  var pos = state.pos;\n  scan(state, Syntax.Anchored.XMLDecl);\n\n  while (consumeMisc(state)) {} // eslint-disable-line no-empty\n\n\n  if (consumeDoctypeDecl(state)) {\n    while (consumeMisc(state)) {} // eslint-disable-line no-empty\n\n  }\n\n  return state.pos > pos;\n}\n\nfunction consumeReference(state) {\n  var _scan8 = scan(state, Syntax.Anchored.Reference),\n      ref = _scan8[0];\n\n  if (ref === void 0) {\n    return false;\n  }\n\n  addText(state, state.replaceReference(ref));\n  return true;\n}\n\nfunction consumeWhitespace(state) {\n  return scan(state, Syntax.Anchored.S).length > 0;\n}\n\nfunction error(state, message) {\n  var pos = state.pos,\n      xml = state.xml;\n  var column = 1;\n  var excerpt = '';\n  var line = 1; // Find the line and column where the error occurred.\n\n  for (var i = 0; i < pos; ++i) {\n    var _char = xml[i];\n\n    if (_char === '\\n') {\n      column = 1;\n      excerpt = '';\n      line += 1;\n    } else {\n      column += 1;\n      excerpt += _char;\n    }\n  }\n\n  var eol = xml.indexOf('\\n', pos);\n  excerpt += eol === -1 ? xml.slice(pos) : xml.slice(pos, eol);\n  var excerptStart = 0; // Keep the excerpt below 50 chars, but always keep the error position in\n  // view.\n\n  if (excerpt.length > 50) {\n    if (column < 40) {\n      excerpt = excerpt.slice(0, 50);\n    } else {\n      excerptStart = column - 20;\n      excerpt = excerpt.slice(excerptStart, column + 30);\n    }\n  }\n\n  var err = new Error(message + \" (line \" + line + \", column \" + column + \")\\n\" + (\"  \" + excerpt + \"\\n\") + ' '.repeat(column - excerptStart + 1) + '^\\n');\n  err.column = column;\n  err.excerpt = excerpt;\n  err.line = line;\n  err.pos = pos;\n  throw err;\n}\n\nfunction isEof(state) {\n  return state.pos >= state.length - 1;\n}\n\nfunction nodeToJson() {\n  var json = Object.assign(Object.create(null), this); // eslint-disable-line no-invalid-this\n\n  delete json.parent;\n  return json;\n}\n\nfunction normalizeAttrValue(state, value) {\n  return value.replace(/[\\x20\\t\\r\\n]/g, ' ').replace(Syntax.Global.Reference, state.replaceReference);\n}\n\nfunction parseAttrs(state, attrs) {\n  var parsedAttrs = Object.create(null);\n\n  if (!attrs) {\n    return parsedAttrs;\n  }\n\n  var attrPairs = attrs.match(Syntax.Global.Attribute).sort();\n\n  for (var i = 0, len = attrPairs.length; i < len; ++i) {\n    var attrPair = attrPairs[i];\n    var eqMatch = attrPair.match(Syntax.Eq);\n    var name = attrPair.slice(0, eqMatch.index);\n    var value = attrPair.slice(eqMatch.index + eqMatch[0].length);\n\n    if (name in parsedAttrs) {\n      state.pos = state.prevPos;\n      error(state, \"Attribute `\" + name + \"` redefined\");\n    }\n\n    value = normalizeAttrValue(state, value.slice(1, -1));\n\n    if (name === 'xml:space') {\n      if (value !== 'default' && value !== 'preserve') {\n        state.pos = state.prevPos;\n        error(state, \"Value of the `xml:space` attribute must be \\\"default\\\" or \\\"preserve\\\"\");\n      }\n    }\n\n    parsedAttrs[name] = value;\n  }\n\n  return parsedAttrs;\n}\n\nfunction replaceReference(ref) {\n  var state = this; // eslint-disable-line no-invalid-this\n\n  if (ref[ref.length - 1] !== ';') {\n    error(state, \"Invalid reference: `\" + ref + \"`\");\n  }\n\n  if (ref[1] === '#') {\n    // This is a character entity.\n    var codePoint;\n\n    if (ref[2] === 'x') {\n      codePoint = parseInt(ref.slice(3, -1), 16);\n    } else {\n      codePoint = parseInt(ref.slice(2, -1), 10);\n    }\n\n    if (isNaN(codePoint)) {\n      state.pos = state.prevPos;\n      error(state, \"Invalid character entity `\" + ref + \"`\");\n    }\n\n    var _char2 = String.fromCodePoint(codePoint);\n\n    if (!Syntax.Char.test(_char2)) {\n      state.pos = state.prevPos;\n      error(state, \"Invalid character entity `\" + ref + \"`\");\n    }\n\n    return _char2;\n  } // This is a named entity.\n\n\n  var value = namedEntities[ref];\n\n  if (value !== void 0) {\n    return value;\n  }\n\n  if (state.options.resolveUndefinedEntity) {\n    var resolvedValue = state.options.resolveUndefinedEntity(ref);\n\n    if (resolvedValue !== null && resolvedValue !== void 0) {\n      return resolvedValue;\n    }\n  }\n\n  if (state.options.ignoreUndefinedEntities) {\n    return ref;\n  }\n\n  state.pos = state.prevPos;\n  error(state, \"Named entity isn't defined: `\" + ref + \"`\");\n}\n\nfunction scan(state, regex) {\n  var pos = state.pos,\n      xml = state.xml;\n  var xmlToScan = pos > 0 ? xml.slice(pos) : xml;\n  var matches = xmlToScan.match(regex);\n\n  if (matches === null) {\n    return emptyArray;\n  }\n\n  state.prevPos = state.pos;\n  state.pos += matches[0].length;\n  return matches;\n}","import React from 'react'\n\nimport styles from './breadcrumb.module.scss'\n\nexport default ({ children, ...others }) => {\n  if (!children) {\n    return\n  }\n\n  if (!Array.isArray(children)) {\n    children = [children]\n  }\n\n  return (\n    <ul className={styles.breadcrumb} {...others}>\n      {children.map((child, index) =>\n        <li key={index}>{child}</li>\n      )}\n    </ul>\n  )\n}\n","const parse = require('@rgrove/parse-xml')\n\n/**\n * Gets the XML representation of a node.\n *\n * @param {object} node\n * A node to render markup for. If the node has children, they will be visited\n * recursively.\n *\n * @param {boolean} [include]\n * Whether to include the root node.\n *\n * @returns {string}\n * The XML representation of the node.\n */\nfunction getMarkup (node, include = false) {\n  switch (node.type) {\n    case 'document':\n      return node.children.map(getMarkup).join('')\n\n    case 'element':\n      const content = node.children\n        .map(c => getMarkup(c, true))\n        .join('')\n\n      if (!include) {\n        return content.trim()\n      }\n\n      const name = node.name\n      const attributes = Object.keys(node.attributes)\n        .map(k => ` ${k}=\"${node.attributes[k].replace(/\"/, '&#34;')}\"`)\n        .join('')\n\n      return `<${name}${attributes}` + (content.length > 0 ? `>${content}</${name}>` : ` />`)\n\n    case 'text':\n      return node.text\n\n    default:\n      return ''\n  }\n}\n\n/**\n * Gets the inner text of an XML node.\n *\n * @param {object} node\n * A node to extract text from. If the node has children, they will be visited\n * recursively.\n *\n * @returns {string}\n * The inner text of the node with leading and trailing whitespace removed and\n * all other whitespace compacted.\n */\nfunction getText (node) {\n  switch (node.type) {\n    case 'document':\n    case 'element':\n      return node.children.map(getText).join('')\n\n    case 'text':\n      return node.text.replace(/\\s+/, ' ').trim()\n\n    default:\n      return ''\n  }\n}\n\nmodule.exports = {\n  getMarkup,\n  getText,\n  parse\n}\n"],"sourceRoot":""}